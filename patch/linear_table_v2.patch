From 380dbedfa2a91de2235b5a265899eb65a1eb7cae Mon Sep 17 00:00:00 2001
From: tacinight <tacingiht@gmail.com>
Date: Sat, 28 Jul 2018 14:42:23 +0800
Subject: [PATCH] introduce LinearTable v2 for small hash

Signed-off-by: tacinight <tacingiht@gmail.com>
---
 gc.c                   |  19 +-
 hash.c                 | 909 +++++++++++++++++++++++++++++++++++++++++++------
 include/ruby/st.h      |   2 +-
 internal.h             |  23 +-
 st.c                   |  20 +-
 test/ruby/test_time.rb |   1 +
 thread.c               |   8 +-
 7 files changed, 858 insertions(+), 124 deletions(-)

diff --git a/gc.c b/gc.c
index ba1bbbfe08..f8948db1c7 100644
--- a/gc.c
+++ b/gc.c
@@ -2251,6 +2251,9 @@ obj_free(rb_objspace_t *objspace, VALUE obj)
 	rb_ary_free(obj);
 	break;
       case T_HASH:
+	if (RANY(obj)->as.hash.ltbl) {
+	    free(RANY(obj)->as.hash.ltbl);
+	}
 	if (RANY(obj)->as.hash.ntbl) {
 	    st_free_table(RANY(obj)->as.hash.ntbl);
 	}
@@ -3264,6 +3267,9 @@ obj_memsize_of(VALUE obj, int use_all_types)
 	size += rb_ary_memsize(obj);
 	break;
       case T_HASH:
+        if (RHASH(obj)->ltbl) {
+	    size += sizeof(li_table);
+	}
 	if (RHASH(obj)->ntbl) {
 	    size += st_memsize(RHASH(obj)->ntbl);
 	}
@@ -4158,6 +4164,16 @@ mark_hash(rb_objspace_t *objspace, st_table *tbl)
     st_foreach(tbl, mark_keyvalue, (st_data_t)objspace);
 }
 
+static void
+mark_hash_linear(rb_objspace_t *objspace, VALUE obj)
+{
+    if (RHASH(obj)->ltbl)
+        linear_foreach(RHASH(obj)->ltbl, mark_keyvalue, (st_data_t)objspace);
+    else if (RHASH(obj)->ntbl)
+        st_foreach(RHASH(obj)->ntbl, mark_keyvalue, (st_data_t)objspace);
+    gc_mark(objspace, RHASH(obj)->ifnone);
+}
+
 void
 rb_mark_hash(st_table *tbl)
 {
@@ -4617,8 +4633,7 @@ gc_mark_children(rb_objspace_t *objspace, VALUE obj)
 	break;
 
       case T_HASH:
-	mark_hash(objspace, any->as.hash.ntbl);
-	gc_mark(objspace, any->as.hash.ifnone);
+	mark_hash_linear(objspace, obj);
 	break;
 
       case T_STRING:
diff --git a/hash.c b/hash.c
index 48fbe1f37c..87e8ae479f 100644
--- a/hash.c
+++ b/hash.c
@@ -21,6 +21,7 @@
 #include "symbol.h"
 #include "gc.h"
 
+#include <assert.h>
 #ifdef __APPLE__
 # ifdef HAVE_CRT_EXTERNS_H
 #  include <crt_externs.h>
@@ -299,6 +300,438 @@ static const struct st_hash_type identhash = {
     rb_ident_hash,
 };
 
+#define EQUAL(tab,x,y) ((x) == (y) || (*(tab)->type->compare)((x),(y)) == 0)
+#define PTR_EQUAL(tab, index, hash_val, key_) \
+    ((tab->hashes[index]) == (hash_val) && EQUAL((tab), (key_), (tab->pairs[index]).key))
+
+#define RESERVED_HASH_VAL ((st_hash_t) 0)
+#define RESERVED_HASH_SUBSTITUTION_VAL (~(st_hash_t) 0)
+
+#define HASH_HAS_NO_TABLE(hash) !(RHASH(hash)->ltbl) && !(RHASH(hash)->ntbl)
+#define HASH_HAS_TABLE(hash) RHASH(hash)->ltbl || RHASH(hash)->ntbl
+
+#define SET_HASH(hash, _hash) (hash) = (_hash)
+#define SET_KEY(pair, _key) (pair).key = (_key)
+#define SET_RECORD(pair, _value) (pair).record = (_value)
+
+#define EMPTY_ENTRY(tab, index) (tab->hashes[index]) == 0
+#define RHASH_TYPE(h) (RHASH(h)->ltbl) ? (RHASH(h)->ltbl->type) : (RHASH(h)->ntbl->type)
+
+typedef st_data_t st_hash_t;
+
+static inline st_hash_t
+do_hash(st_data_t key, li_table *tab)
+{
+    st_hash_t hash = (st_hash_t)(tab->type->hash)(key);
+
+    return hash == ((st_hash_t) 0) ? (~(st_hash_t) 0) : hash;
+}
+
+static inline void
+set_entry(li_table *tab, uint8_t index, st_data_t key, st_data_t val, st_hash_t hash)
+{
+    SET_HASH(tab->hashes[index], hash);
+    SET_KEY(tab->pairs[index], key);
+    SET_RECORD(tab->pairs[index], val);
+}
+
+static inline void
+clear_entry(li_table* tab, uint8_t index)
+{
+    SET_KEY(tab->pairs[index], Qundef);
+    SET_RECORD(tab->pairs[index], Qundef);
+    SET_HASH(tab->hashes[index], 0);
+}
+
+static li_table*
+linear_init_table(const struct st_hash_type *type)
+{
+    li_table *tab;
+    tab = (li_table*)malloc(sizeof(li_table));
+    if (UNLIKELY(tab == NULL)) rb_bug("linear_init_table: malloc failed");
+    tab->type = type;
+    tab->num_entries = 0;
+    tab->entries_bound = 0;
+    memset(tab->hashes, 0, LINEAR_TABLE_MAX_SIZE * sizeof(st_hash_t));
+    memset(tab->pairs, Qundef, LINEAR_TABLE_MAX_SIZE * (sizeof(LinearPair)));
+    return tab;
+}
+
+static li_table*
+linear_init_identtable(void)
+{
+    return linear_init_table(&identhash);
+}
+
+static li_table*
+linear_init_objtable(void)
+{
+    return linear_init_table(&objhash);
+}
+
+static st_index_t
+find_entry(li_table *tab, st_hash_t hash_value, st_data_t key)
+{
+    uint8_t i;
+
+    if (tab->num_entries == 0) return LINEAR_TABLE_BOUND;
+    for (i = 0; i < LINEAR_TABLE_BOUND; i++) {
+	if (PTR_EQUAL(tab, i, hash_value, key))
+	      return i;
+    }
+    return LINEAR_TABLE_BOUND;
+}
+
+static void
+try_convert_table(VALUE hash)
+{
+    st_table *new_tab;
+    li_table *tab;
+    LinearPair *pairs;
+    uint8_t i;
+
+    tab = RHASH(hash)->ltbl;
+    if (!tab || tab->num_entries < LINEAR_TABLE_MAX_SIZE)
+	return;
+
+    new_tab = st_init_table_with_size(tab->type, tab->num_entries * 2);
+
+    pairs = tab->pairs;
+    for (i = 0; i < LINEAR_TABLE_BOUND; i++) {
+	st_add_direct(new_tab, pairs[i].key, pairs[i].record);
+    }
+    free(tab);
+    RHASH(hash)->ltbl = NULL;
+    RHASH(hash)->ntbl = new_tab;
+    return;
+}
+
+static struct st_table *
+force_convert_table(VALUE hash)
+{
+    st_table *new_tab;
+    li_table *tab;
+    LinearPair *pairs;
+    uint8_t i;
+
+    if (RHASH(hash)->ntbl)
+        return RHASH(hash)->ntbl;
+
+    tab = RHASH(hash)->ltbl;
+    if (tab) {
+        new_tab = st_init_table_with_size(tab->type, tab->num_entries);
+	pairs = tab->pairs;
+	for (i = 0; i < LINEAR_TABLE_BOUND; i++) {
+	    if (EMPTY_ENTRY(tab, i)) continue;
+	    st_add_direct(new_tab, pairs[i].key, pairs[i].record);
+	}
+	free(tab);
+    }
+    else if (!RHASH(hash)->ntbl) {
+	new_tab = st_init_table(&objhash);
+    }
+    RHASH(hash)->ltbl = NULL;
+    RHASH(hash)->ntbl = new_tab;
+    return RHASH(hash)->ntbl;
+}
+
+static int
+compact_table(li_table *tab)
+{
+    LinearPair *pairs;
+    uint8_t empty = 0, non_empty = 1;
+
+    pairs = tab->pairs;
+    for (; non_empty < LINEAR_TABLE_BOUND; empty++, non_empty++) {
+	while (!EMPTY_ENTRY(tab, empty)) {
+	    empty++;
+	    if (empty == LINEAR_TABLE_BOUND - 1) goto done;
+	}
+
+	if (non_empty <= empty) non_empty = empty + 1;
+	while (EMPTY_ENTRY(tab, non_empty)) {
+	    non_empty++;
+	    if (non_empty == LINEAR_TABLE_BOUND) goto done;
+	}
+
+	pairs[empty] = pairs[non_empty];
+	tab->hashes[empty] = tab->hashes[non_empty];
+	clear_entry(tab, non_empty);
+    }
+done:
+    assert(empty < LINEAR_TABLE_BOUND);
+    return empty;
+}
+
+static int
+add_direct_with_hash(li_table *tab, st_data_t key, st_data_t val, st_hash_t hash)
+{
+    if (tab->num_entries >= LINEAR_TABLE_MAX_SIZE)
+	return 1;
+
+    if (UNLIKELY(tab->entries_bound >= LINEAR_TABLE_BOUND))
+        tab->entries_bound = compact_table(tab);
+
+    assert(tab->entries_bound < LINEAR_TABLE_BOUND);
+    set_entry(tab, tab->entries_bound++, key, val, hash);
+    tab->num_entries++;
+    return 0;
+}
+
+int
+linear_foreach(li_table *tab, int (*func)(ANYARGS), st_data_t arg)
+{
+    uint8_t i;
+    LinearPair *pair, *pairs;
+    enum st_retval retval;
+
+    pairs = tab->pairs;
+    for (i = 0; i < LINEAR_TABLE_BOUND; i++) {
+	pair = &pairs[i];
+	if (EMPTY_ENTRY(tab, i))
+	    continue;
+	retval = (*func)(pair->key, pair->record, arg, 0);
+	switch (retval) {
+	    case ST_CONTINUE:
+	        break;
+	    case ST_CHECK:
+	    case ST_STOP:
+	        return 0;
+	    case ST_DELETE:
+		clear_entry(tab, i);
+		tab->num_entries--;
+		break;
+	}
+    }
+    return 0;
+}
+
+static int
+linear_foreach_check(li_table *tab, int (*func)(ANYARGS), st_data_t arg,
+                 st_data_t never)
+{
+    uint8_t i, ret = 0;
+    LinearPair *pair, *pairs;
+    enum st_retval retval;
+    st_data_t key;
+    st_hash_t hash;
+
+    if (tab->num_entries == 0) return 0;
+    pairs = tab->pairs;
+    for (i = 0; i < LINEAR_TABLE_BOUND; i++) {
+	pair = &pairs[i];
+	if (EMPTY_ENTRY(tab, i))
+	    continue;
+	key = pair->key;
+	hash = tab->hashes[i];
+	retval = (*func)(key, pair->record, arg, 0);
+	switch (retval) {
+	    case ST_CHECK: {
+		if (pair->key == never && tab->hashes[i] == 0)
+		    break;
+		ret = find_entry(tab, hash, key);
+		if (ret == LINEAR_TABLE_BOUND) {
+		    retval = (*func)(0, 0, arg, 1);
+		    return 2;
+		}
+	    }
+	    case ST_CONTINUE:
+	        break;
+	    case ST_STOP:
+	        return 0;
+	    case ST_DELETE: {
+		clear_entry(tab, i);
+		tab->num_entries--;
+		break;
+	    }
+	}
+    }
+    return 0;
+}
+
+static int
+linear_update(li_table *tab, st_data_t key,
+	      st_update_callback_func *func, st_data_t arg)
+{
+    LinearPair *pair;
+    int retval, existing;
+    uint8_t bin;
+    st_data_t value = 0, old_key;
+    st_hash_t hash = do_hash(key, tab);
+
+    bin = find_entry(tab, hash, key);
+    existing = bin != LINEAR_TABLE_BOUND;
+    pair = &tab->pairs[bin];
+    if (existing) {
+	key = pair->key;
+	value = pair->record;
+    }
+    old_key = key;
+    retval = (*func)(&key, &value, arg, existing);
+
+    switch (retval) {
+	case ST_CONTINUE:
+	    if (!existing) {
+		if (add_direct_with_hash(tab, key, value, hash))
+		    return -1;
+		break;
+	    }
+	    if (old_key != key) {
+		pair->key = key;
+	    }
+	    pair->record = value;
+	    break;
+	case ST_DELETE:
+	    if (existing) {
+		clear_entry(tab, bin);
+		tab->num_entries--;
+	    }
+	    break;
+    }
+    return existing;
+}
+
+static int
+linear_insert(li_table *tab, st_data_t key, st_data_t value)
+{
+    uint8_t bin;
+    st_hash_t hash_value;
+
+    hash_value = do_hash(key, tab);
+    bin = find_entry(tab, hash_value, key);
+    if (bin == LINEAR_TABLE_BOUND) {
+	if (UNLIKELY(tab->num_entries >= LINEAR_TABLE_MAX_SIZE))
+	    return -1;
+	if (UNLIKELY(tab->entries_bound >= LINEAR_TABLE_BOUND))
+	    tab->entries_bound = compact_table(tab);
+	assert(tab->entries_bound < LINEAR_TABLE_BOUND);
+	set_entry(tab, tab->entries_bound++, key, value, hash_value);
+	tab->num_entries++;
+	return 0;
+    }
+    tab->pairs[bin].record = value;
+    return 1;
+}
+
+int
+linear_lookup(li_table *tab, st_data_t key, st_data_t *value)
+{
+    uint8_t bin;
+    st_hash_t hash_value;
+
+    hash_value = do_hash(key, tab);
+    bin = find_entry(tab, hash_value, key);
+    if (bin == LINEAR_TABLE_BOUND) {
+	return 0;
+    }
+    assert(bin < LINEAR_TABLE_BOUND);
+    if (value != 0)
+        *value = tab->pairs[bin].record;
+    return 1;
+}
+
+static int
+linear_delete(li_table *tab, st_data_t *key, st_data_t *value)
+{
+    uint8_t bin;
+    st_hash_t hash_value;
+
+    hash_value = do_hash(*key, tab);
+    bin = find_entry(tab, hash_value, *key);
+    if (bin == LINEAR_TABLE_BOUND) {
+	if (value != 0) *value = 0;
+	return 0;
+    }
+    if (value != 0) *value = tab->pairs[bin].record;
+    clear_entry(tab, bin);
+    tab->num_entries--;
+    return 1;
+}
+
+static int
+linear_shift(li_table *tab, st_data_t *key, st_data_t *value)
+{
+    uint8_t i;
+    LinearPair *pair, *pairs;
+
+    pairs = tab->pairs;
+    for (i = 0; i < LINEAR_TABLE_BOUND; i++) {
+	pair = &pairs[i];
+	if (!EMPTY_ENTRY(tab, i)) {
+	    if (value != 0) *value = pair->record;
+	    *key = pair->key;
+	    clear_entry(tab, i);
+	    tab->num_entries--;
+	    return 1;
+	}
+    }
+    if (value != 0) *value = 0;
+    return 0;
+}
+
+static int
+linear_keys(li_table *tab, st_data_t *keys, st_index_t size)
+{
+    uint8_t i;
+    st_data_t *keys_start, *keys_end;
+    LinearPair *pairs = tab->pairs;
+
+    keys_start = keys;
+    keys_end = keys + size;
+    for (i = 0; i < LINEAR_TABLE_BOUND; i++) {
+	if (keys == keys_end)
+	    break;
+	if (!EMPTY_ENTRY(tab, i))
+	    *keys++ = pairs[i].key;
+    }
+
+    return keys - keys_start;
+}
+
+static int
+linear_values(li_table *tab, st_data_t *values, st_index_t size)
+{
+    uint8_t i;
+    st_data_t *values_start, *values_end;
+    LinearPair *pairs = tab->pairs;
+
+    values_start = values;
+    values_end = values + size;
+    for (i = 0; i < LINEAR_TABLE_BOUND; i++) {
+	if (values == values_end)
+	    break;
+	if (!EMPTY_ENTRY(tab, i))
+	    *values++ = pairs[i].record;
+    }
+
+    return values - values_start;
+}
+
+static li_table*
+linear_copy(li_table *old_tab)
+{
+    li_table *new_tab;
+    new_tab = (li_table*) malloc(sizeof(li_table));
+    if (UNLIKELY(new_tab == NULL)) rb_bug("linear_copy: malloc failed");
+    *new_tab = *old_tab;
+    return new_tab;
+}
+
+static void
+linear_clear(li_table *tab)
+{
+    tab->num_entries = 0;
+    tab->entries_bound = 0;
+    memset(tab->hashes, 0, LINEAR_TABLE_MAX_SIZE * sizeof(st_hash_t));
+    memset(tab->pairs, Qundef, LINEAR_TABLE_MAX_SIZE * sizeof(LinearPair));
+}
+
+static inline void
+linear_free_table(li_table *tab)
+{
+    free(tab);
+}
+
 typedef int st_foreach_func(st_data_t, st_data_t, st_data_t);
 
 struct foreach_safe_arg {
@@ -343,6 +776,30 @@ struct hash_foreach_arg {
 };
 
 static int
+hash_linear_foreach_iter(st_data_t key, st_data_t value, st_data_t argp, int error)
+{
+    struct hash_foreach_arg *arg = (struct hash_foreach_arg *)argp;
+    int status;
+    li_table *tbl;
+
+    if (error) return ST_STOP;
+    tbl = RHASH(arg->hash)->ltbl;
+    status = (*arg->func)((VALUE)key, (VALUE)value, arg->arg);
+    if (RHASH(arg->hash)->ltbl != tbl) {
+	rb_raise(rb_eRuntimeError, "rehash occurred during iteration");
+    }
+    switch (status) {
+      case ST_DELETE:
+	return ST_DELETE;
+      case ST_CONTINUE:
+	break;
+      case ST_STOP:
+	return ST_STOP;
+    }
+    return ST_CHECK;
+}
+
+static int
 hash_foreach_iter(st_data_t key, st_data_t value, st_data_t argp, int error)
 {
     struct hash_foreach_arg *arg = (struct hash_foreach_arg *)argp;
@@ -384,7 +841,14 @@ static VALUE
 hash_foreach_call(VALUE arg)
 {
     VALUE hash = ((struct hash_foreach_arg *)arg)->hash;
-    if (st_foreach_check(RHASH(hash)->ntbl, hash_foreach_iter, (st_data_t)arg, (st_data_t)Qundef)) {
+    int ret = 0;
+    if (RHASH(hash)->ltbl)
+	ret = linear_foreach_check(RHASH(hash)->ltbl, hash_linear_foreach_iter,
+	                           (st_data_t)arg, (st_data_t)Qundef);
+    else if (RHASH(hash)->ntbl)
+	ret = st_foreach_check(RHASH(hash)->ntbl, hash_foreach_iter,
+	                        (st_data_t)arg, (st_data_t)Qundef);
+    if (ret) {
 	rb_raise(rb_eRuntimeError, "hash modified during iteration");
     }
     return Qnil;
@@ -395,7 +859,7 @@ rb_hash_foreach(VALUE hash, int (*func)(ANYARGS), VALUE farg)
 {
     struct hash_foreach_arg arg;
 
-    if (!RHASH(hash)->ntbl)
+    if (HASH_HAS_NO_TABLE(hash))
         return;
     RHASH_ITER_LEV(hash)++;
     arg.hash = hash;
@@ -447,8 +911,12 @@ MJIT_FUNC_EXPORTED VALUE
 rb_hash_new_with_size(st_index_t size)
 {
     VALUE ret = rb_hash_new();
-    if (size)
-        RHASH(ret)->ntbl = st_init_table_with_size(&objhash, size);
+    if (size) {
+	if (size <= LINEAR_TABLE_MAX_SIZE)
+	    RHASH(ret)->ltbl = linear_init_objtable();
+	else
+	    RHASH(ret)->ntbl = st_init_table_with_size(&objhash, size);
+    }
     return ret;
 }
 
@@ -457,8 +925,12 @@ hash_dup(VALUE hash, VALUE klass, VALUE flags)
 {
     VALUE ret = hash_alloc_flags(klass, flags,
 				 RHASH_IFNONE(hash));
-    if (!RHASH_EMPTY_P(hash))
-	RHASH(ret)->ntbl = st_copy(RHASH(hash)->ntbl);
+    if (!RHASH_EMPTY_P(hash)) {
+	if (RHASH(hash)->ltbl)
+	    RHASH(ret)->ltbl = linear_copy(RHASH(hash)->ltbl);
+	else
+	    RHASH(ret)->ntbl = st_copy(RHASH(hash)->ntbl);
+    }
     return ret;
 }
 
@@ -479,6 +951,15 @@ rb_hash_modify_check(VALUE hash)
     rb_check_frozen(hash);
 }
 
+static li_table *
+hash_ltbl(VALUE hash)
+{
+    if (!RHASH(hash)->ltbl) {
+	RHASH(hash)->ltbl = linear_init_objtable();
+    }
+    return RHASH(hash)->ltbl;
+}
+
 static struct st_table *
 hash_tbl(VALUE hash)
 {
@@ -492,20 +973,21 @@ struct st_table *
 rb_hash_tbl(VALUE hash)
 {
     OBJ_WB_UNPROTECT(hash);
-    return hash_tbl(hash);
+    return force_convert_table(hash);
 }
 
 MJIT_FUNC_EXPORTED struct st_table *
 rb_hash_tbl_raw(VALUE hash)
 {
-    return hash_tbl(hash);
+    return force_convert_table(hash);
 }
 
 static void
 rb_hash_modify(VALUE hash)
 {
     rb_hash_modify_check(hash);
-    hash_tbl(hash);
+    if (HASH_HAS_NO_TABLE(hash))
+        hash_ltbl(hash);
 }
 
 NORETURN(static void no_new_key(void));
@@ -558,7 +1040,15 @@ tbl_update(VALUE hash, VALUE key, tbl_update_func func, st_data_t optional_arg)
     arg.new_value = 0;
     arg.old_value = Qundef;
 
-    result = st_update(RHASH(hash)->ntbl, (st_data_t)key, func, (st_data_t)&arg);
+    if (RHASH(hash)->ltbl) {
+	result = linear_update(RHASH(hash)->ltbl, (st_data_t)key, func, (st_data_t)&arg);
+	if (result == -1) {
+	    try_convert_table(hash);
+	    result = st_update(RHASH(hash)->ntbl, (st_data_t)key, func, (st_data_t)&arg);
+	}
+    }
+    else
+	result = st_update(RHASH(hash)->ntbl, (st_data_t)key, func, (st_data_t)&arg);
 
     /* write barrier */
     if (arg.new_key)   RB_OBJ_WRITTEN(hash, arg.old_key, arg.new_key);
@@ -676,7 +1166,10 @@ rb_hash_s_create(int argc, VALUE *argv, VALUE klass)
 	tmp = rb_hash_s_try_convert(Qnil, argv[0]);
 	if (!NIL_P(tmp)) {
 	    hash = hash_alloc(klass);
-	    if (RHASH(tmp)->ntbl) {
+	    if (RHASH(tmp)->ltbl) {
+		RHASH(hash)->ltbl = linear_copy(RHASH(tmp)->ltbl);
+	    }
+	    else if (RHASH(tmp)->ntbl) {
 		RHASH(hash)->ntbl = st_copy(RHASH(tmp)->ntbl);
 	    }
 	    return hash;
@@ -765,6 +1258,15 @@ struct rehash_arg {
 };
 
 static int
+rb_hash_rehash_opt_i(VALUE key, VALUE value, VALUE arg)
+{
+    li_table *tbl = (li_table *)arg;
+
+    linear_insert(tbl, (st_data_t)key, (st_data_t)value);
+    return ST_CONTINUE;
+}
+
+static int
 rb_hash_rehash_i(VALUE key, VALUE value, VALUE arg)
 {
     st_table *tbl = (st_table *)arg;
@@ -798,22 +1300,32 @@ rb_hash_rehash(VALUE hash)
 {
     VALUE tmp;
     st_table *tbl;
+    li_table *ltbl;
 
     if (RHASH_ITER_LEV(hash) > 0) {
 	rb_raise(rb_eRuntimeError, "rehash during iteration");
     }
     rb_hash_modify_check(hash);
-    if (!RHASH(hash)->ntbl)
-        return hash;
-    tmp = hash_alloc(0);
-    tbl = st_init_table_with_size(RHASH(hash)->ntbl->type, RHASH(hash)->ntbl->num_entries);
-    RHASH(tmp)->ntbl = tbl;
-
-    rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tbl);
-    st_free_table(RHASH(hash)->ntbl);
-    RHASH(hash)->ntbl = tbl;
-    RHASH(tmp)->ntbl = 0;
-
+    if (RHASH(hash)->ltbl) {
+	tmp = hash_alloc(0);
+	ltbl = linear_init_table(RHASH(hash)->ltbl->type);
+	RHASH(tmp)->ltbl = ltbl;
+
+	rb_hash_foreach(hash, rb_hash_rehash_opt_i, (VALUE)ltbl);
+	linear_free_table(RHASH(hash)->ltbl);
+	RHASH(hash)->ltbl = ltbl;
+	RHASH(tmp)->ltbl = 0;
+    }
+    else if (RHASH(hash)->ntbl) {
+	tmp = hash_alloc(0);
+	tbl = st_init_table_with_size(RHASH(hash)->ntbl->type, RHASH(hash)->ntbl->num_entries);
+	RHASH(tmp)->ntbl = tbl;
+
+	rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tbl);
+	st_free_table(RHASH(hash)->ntbl);
+	RHASH(hash)->ntbl = tbl;
+	RHASH(tmp)->ntbl = 0;
+    }
     return hash;
 }
 
@@ -850,10 +1362,13 @@ rb_hash_aref(VALUE hash, VALUE key)
 {
     st_data_t val;
 
-    if (!RHASH(hash)->ntbl || !st_lookup(RHASH(hash)->ntbl, key, &val)) {
-	return rb_hash_default_value(hash, key);
+    if (RHASH(hash)->ltbl && linear_lookup(RHASH(hash)->ltbl, key, &val)) {
+	return (VALUE)val;
+    }
+    else if (RHASH(hash)->ntbl && st_lookup(RHASH(hash)->ntbl, key, &val)) {
+	return (VALUE)val;
     }
-    return (VALUE)val;
+    return rb_hash_default_value(hash, key);
 }
 
 VALUE
@@ -861,10 +1376,13 @@ rb_hash_lookup2(VALUE hash, VALUE key, VALUE def)
 {
     st_data_t val;
 
-    if (!RHASH(hash)->ntbl || !st_lookup(RHASH(hash)->ntbl, key, &val)) {
-	return def; /* without Hash#default */
+    if (RHASH(hash)->ltbl && linear_lookup(RHASH(hash)->ltbl, key, &val)) {
+	return (VALUE)val;
     }
-    return (VALUE)val;
+    else if (RHASH(hash)->ntbl && st_lookup(RHASH(hash)->ntbl, key, &val)) {
+	return (VALUE)val;
+    }
+    return def; /* without Hash#default */
 }
 
 VALUE
@@ -916,19 +1434,22 @@ rb_hash_fetch_m(int argc, VALUE *argv, VALUE hash)
     if (block_given && argc == 2) {
 	rb_warn("block supersedes default value argument");
     }
-    if (!RHASH(hash)->ntbl || !st_lookup(RHASH(hash)->ntbl, key, &val)) {
-	if (block_given) return rb_yield(key);
-	if (argc == 1) {
-	    VALUE desc = rb_protect(rb_inspect, key, 0);
-	    if (NIL_P(desc)) {
-		desc = rb_any_to_s(key);
-	    }
-	    desc = rb_str_ellipsize(desc, 65);
-	    rb_key_err_raise(rb_sprintf("key not found: %"PRIsVALUE, desc), hash, key);
+    if (RHASH(hash)->ltbl && linear_lookup(RHASH(hash)->ltbl, key, &val)) {
+	return (VALUE)val;
+    }
+    else if (RHASH(hash)->ntbl && st_lookup(RHASH(hash)->ntbl, key, &val)) {
+	return (VALUE)val;
+    }
+    if (block_given) return rb_yield(key);
+    if (argc == 1) {
+	VALUE desc = rb_protect(rb_inspect, key, 0);
+	if (NIL_P(desc)) {
+	    desc = rb_any_to_s(key);
 	}
-	return argv[1];
+	desc = rb_str_ellipsize(desc, 65);
+	rb_key_err_raise(rb_sprintf("key not found: %"PRIsVALUE, desc), hash, key);
     }
-    return (VALUE)val;
+    return argv[1];
 }
 
 VALUE
@@ -1117,10 +1638,10 @@ rb_hash_delete_entry(VALUE hash, VALUE key)
 {
     st_data_t ktmp = (st_data_t)key, val;
 
-    if (!RHASH(hash)->ntbl) {
-	return Qundef;
+    if (RHASH(hash)->ltbl && linear_delete(RHASH(hash)->ltbl, &ktmp, &val)) {
+	return (VALUE)val;
     }
-    else if (st_delete(RHASH(hash)->ntbl, &ktmp, &val)) {
+    else if (RHASH(hash)->ntbl && st_delete(RHASH(hash)->ntbl, &ktmp, &val)) {
 	return (VALUE)val;
     }
     else {
@@ -1219,6 +1740,21 @@ rb_hash_shift(VALUE hash)
     struct shift_var var;
 
     rb_hash_modify_check(hash);
+    if (RHASH(hash)->ltbl) {
+	var.key = Qundef;
+	if (RHASH_ITER_LEV(hash) == 0) {
+	    if (linear_shift(RHASH(hash)->ltbl, &var.key, &var.val)) {
+		return rb_assoc_new(var.key, var.val);
+	    }
+	}
+	else {
+	    rb_hash_foreach(hash, shift_i_safe, (VALUE)&var);
+	    if (var.key != Qundef) {
+		rb_hash_delete_entry(hash, var.key);
+		return rb_assoc_new(var.key, var.val);
+	    }
+	}
+    }
     if (RHASH(hash)->ntbl) {
 	var.key = Qundef;
 	if (RHASH_ITER_LEV(hash) == 0) {
@@ -1272,7 +1808,7 @@ rb_hash_delete_if(VALUE hash)
 {
     RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
     rb_hash_modify_check(hash);
-    if (RHASH(hash)->ntbl)
+    if (HASH_HAS_TABLE(hash))
 	rb_hash_foreach(hash, delete_if_i, hash);
     return hash;
 }
@@ -1296,7 +1832,7 @@ rb_hash_reject_bang(VALUE hash)
     n = RHASH_SIZE(hash);
     if (!n) return Qnil;
     rb_hash_foreach(hash, delete_if_i, hash);
-    if (n == RHASH(hash)->ntbl->num_entries) return Qnil;
+    if (n == RHASH_SIZE(hash)) return Qnil;
     return hash;
 }
 
@@ -1486,11 +2022,10 @@ rb_hash_select_bang(VALUE hash)
 
     RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
     rb_hash_modify_check(hash);
-    if (!RHASH(hash)->ntbl)
-        return Qnil;
-    n = RHASH(hash)->ntbl->num_entries;
+    n = RHASH_SIZE(hash);
+    if (!n) return Qnil;
     rb_hash_foreach(hash, keep_if_i, hash);
-    if (n == RHASH(hash)->ntbl->num_entries) return Qnil;
+    if (n == RHASH_SIZE(hash)) return Qnil;
     return hash;
 }
 
@@ -1511,7 +2046,7 @@ rb_hash_keep_if(VALUE hash)
 {
     RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
     rb_hash_modify_check(hash);
-    if (RHASH(hash)->ntbl)
+    if (HASH_HAS_TABLE(hash))
 	rb_hash_foreach(hash, keep_if_i, hash);
     return hash;
 }
@@ -1537,9 +2072,13 @@ VALUE
 rb_hash_clear(VALUE hash)
 {
     rb_hash_modify_check(hash);
-    if (!RHASH(hash)->ntbl)
-        return hash;
-    if (RHASH(hash)->ntbl->num_entries > 0) {
+    if (RHASH(hash)->ltbl && RHASH(hash)->ltbl->num_entries > 0) {
+	if (RHASH_ITER_LEV(hash) > 0)
+	    rb_hash_foreach(hash, clear_i, 0);
+	else
+	    linear_clear(RHASH(hash)->ltbl);
+    }
+    else if (RHASH(hash)->ntbl && RHASH(hash)->ntbl->num_entries > 0) {
 	if (RHASH_ITER_LEV(hash) > 0)
 	    rb_hash_foreach(hash, clear_i, 0);
 	else
@@ -1640,14 +2179,15 @@ VALUE
 rb_hash_aset(VALUE hash, VALUE key, VALUE val)
 {
     int iter_lev = RHASH_ITER_LEV(hash);
-    st_table *tbl = RHASH(hash)->ntbl;
+    const struct st_hash_type *type;
 
     rb_hash_modify(hash);
-    if (!tbl) {
+    if (HASH_HAS_NO_TABLE(hash)) {
 	if (iter_lev > 0) no_new_key();
-	tbl = hash_tbl(hash);
+	RHASH(hash)->ltbl = linear_init_objtable();
     }
-    if (tbl->type == &identhash || rb_obj_class(key) != rb_cString) {
+    type = RHASH_TYPE(hash);
+    if (type == &identhash || rb_obj_class(key) != rb_cString) {
 	RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset, val);
     }
     else {
@@ -1669,6 +2209,7 @@ static VALUE
 rb_hash_initialize_copy(VALUE hash, VALUE hash2)
 {
     st_table *ntbl;
+    li_table *ltbl;
 
     rb_hash_modify_check(hash);
     hash2 = to_hash(hash2);
@@ -1677,13 +2218,23 @@ rb_hash_initialize_copy(VALUE hash, VALUE hash2)
 
     if (hash == hash2) return hash;
 
+    ltbl = RHASH(hash)->ltbl;
     ntbl = RHASH(hash)->ntbl;
-    if (RHASH(hash2)->ntbl) {
+    if (RHASH(hash2)->ltbl) {
+	if (ltbl) linear_free_table(ltbl);
+	RHASH(hash)->ltbl = linear_copy(RHASH(hash2)->ltbl);
+	if (RHASH(hash)->ltbl->num_entries)
+	    rb_hash_rehash(hash);
+    }
+    else if (RHASH(hash2)->ntbl) {
 	if (ntbl) st_free_table(ntbl);
         RHASH(hash)->ntbl = st_copy(RHASH(hash2)->ntbl);
 	if (RHASH(hash)->ntbl->num_entries)
 	    rb_hash_rehash(hash);
     }
+    else if (ltbl) {
+	linear_clear(ltbl);
+    }
     else if (ntbl) {
 	st_clear(ntbl);
     }
@@ -1708,18 +2259,20 @@ rb_hash_initialize_copy(VALUE hash, VALUE hash2)
 static VALUE
 rb_hash_replace(VALUE hash, VALUE hash2)
 {
-    st_table *table2;
-
     rb_hash_modify_check(hash);
     if (hash == hash2) return hash;
     hash2 = to_hash(hash2);
 
     COPY_DEFAULT(hash, hash2);
 
-    table2 = RHASH(hash2)->ntbl;
-
     rb_hash_clear(hash);
-    if (table2) hash_tbl(hash)->type = table2->type;
+    if (RHASH(hash2)->ltbl) {
+	hash_ltbl(hash)->type = RHASH(hash2)->ltbl->type;
+    }
+    else if (RHASH(hash2)->ntbl) {
+	hash_tbl(hash)->type = RHASH(hash2)->ntbl->type;
+    }
+
     rb_hash_foreach(hash2, replace_i, hash);
 
     return hash;
@@ -1941,7 +2494,7 @@ rb_hash_transform_keys_bang(VALUE hash)
 {
     RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
     rb_hash_modify_check(hash);
-    if (RHASH(hash)->ntbl) {
+    if (HASH_HAS_TABLE(hash)) {
         long i;
         VALUE pairs = rb_hash_flatten(0, NULL, hash);
         rb_hash_clear(hash);
@@ -2015,7 +2568,7 @@ rb_hash_transform_values_bang(VALUE hash)
 {
     RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
     rb_hash_modify_check(hash);
-    if (RHASH(hash)->ntbl)
+    if (HASH_HAS_TABLE(hash))
         rb_hash_foreach(hash, transform_values_i, hash);
     return hash;
 }
@@ -2165,12 +2718,22 @@ rb_hash_keys(VALUE hash)
     if (size == 0) return keys;
 
     if (ST_DATA_COMPATIBLE_P(VALUE)) {
-	st_table *table = RHASH(hash)->ntbl;
+	if (RHASH(hash)->ltbl) {
+	    li_table *table = RHASH(hash)->ltbl;
+
+	    rb_gc_writebarrier_remember(keys);
+	    RARRAY_PTR_USE(keys, ptr, {
+		size = linear_keys(table, ptr, size);
+	    });
+	}
+	else {
+	    st_table *table = RHASH(hash)->ntbl;
 
-	rb_gc_writebarrier_remember(keys);
-	RARRAY_PTR_USE(keys, ptr, {
-	    size = st_keys(table, ptr, size);
-	});
+	    rb_gc_writebarrier_remember(keys);
+	    RARRAY_PTR_USE(keys, ptr, {
+		 size = st_keys(table, ptr, size);
+	    });
+	}
 	rb_ary_set_len(keys, size);
     }
     else {
@@ -2209,12 +2772,22 @@ rb_hash_values(VALUE hash)
     if (size == 0) return values;
 
     if (ST_DATA_COMPATIBLE_P(VALUE)) {
-	st_table *table = RHASH(hash)->ntbl;
+	if (RHASH(hash)->ltbl) {
+	    li_table *table = RHASH(hash)->ltbl;
 
-	rb_gc_writebarrier_remember(values);
-	RARRAY_PTR_USE(values, ptr, {
-	    size = st_values(table, ptr, size);
-	});
+	    rb_gc_writebarrier_remember(values);
+	    RARRAY_PTR_USE(values, ptr, {
+		size = linear_values(table, ptr, size);
+	    });
+	}
+	else {
+	    st_table *table = RHASH(hash)->ntbl;
+
+	    rb_gc_writebarrier_remember(values);
+	    RARRAY_PTR_USE(values, ptr, {
+		size = st_values(table, ptr, size);
+	    });
+	}
 	rb_ary_set_len(values, size);
     }
     else {
@@ -2246,9 +2819,10 @@ rb_hash_values(VALUE hash)
 MJIT_FUNC_EXPORTED VALUE
 rb_hash_has_key(VALUE hash, VALUE key)
 {
-    if (!RHASH(hash)->ntbl)
-        return Qfalse;
-    if (st_lookup(RHASH(hash)->ntbl, key, 0)) {
+    if (RHASH(hash)->ltbl && linear_lookup(RHASH(hash)->ltbl, key, 0)) {
+        return Qtrue;
+    }
+    else if (RHASH(hash)->ntbl && st_lookup(RHASH(hash)->ntbl, key, 0)) {
 	return Qtrue;
     }
     return Qfalse;
@@ -2313,6 +2887,42 @@ eql_i(VALUE key, VALUE val1, VALUE arg)
     return ST_CONTINUE;
 }
 
+struct equal_data_opt {
+    VALUE result;
+    li_table *tbl;
+    int eql;
+};
+
+static int
+eql_opt_i(VALUE key, VALUE val1, VALUE arg)
+{
+    struct equal_data_opt *data = (struct equal_data_opt *)arg;
+    st_data_t val2;
+
+    if (!linear_lookup(data->tbl, key, &val2)) {
+	data->result = Qfalse;
+	return ST_STOP;
+    }
+    if (!(data->eql ? rb_eql(val1, (VALUE)val2) : (int)rb_equal(val1, (VALUE)val2))) {
+	data->result = Qfalse;
+	return ST_STOP;
+    }
+    return ST_CONTINUE;
+}
+
+static VALUE
+recursive_eql_opt(VALUE hash, VALUE dt, int recur)
+{
+    struct equal_data_opt *data;
+
+    if (recur) return Qtrue;
+    data = (struct equal_data_opt*)dt;
+    data->result = Qtrue;
+    rb_hash_foreach(hash, eql_opt_i, dt);
+
+    return data->result;
+}
+
 static VALUE
 recursive_eql(VALUE hash, VALUE dt, int recur)
 {
@@ -2330,6 +2940,7 @@ static VALUE
 hash_equal(VALUE hash1, VALUE hash2, int eql)
 {
     struct equal_data data;
+    struct equal_data_opt data_opt;
 
     if (hash1 == hash2) return Qtrue;
     if (!RB_TYPE_P(hash2, T_HASH)) {
@@ -2350,19 +2961,28 @@ hash_equal(VALUE hash1, VALUE hash2, int eql)
     }
     if (RHASH_SIZE(hash1) != RHASH_SIZE(hash2))
 	return Qfalse;
-    if (!RHASH(hash1)->ntbl || !RHASH(hash2)->ntbl)
-        return Qtrue;
-    if (RHASH(hash1)->ntbl->type != RHASH(hash2)->ntbl->type)
-	return Qfalse;
+    if (RHASH(hash1)->ltbl && RHASH(hash2)->ltbl) {
+        if (RHASH(hash1)->ltbl->type != RHASH(hash2)->ltbl->type)
+            return Qfalse;
+
+	data_opt.tbl = RHASH(hash2)->ltbl;
+	data_opt.eql = eql;
+	return rb_exec_recursive_paired(recursive_eql_opt, hash1, hash2, (VALUE)&data_opt);
+    }
+    else if (RHASH(hash1)->ntbl && RHASH(hash2)->ntbl) {
+        if (RHASH(hash1)->ntbl->type != RHASH(hash2)->ntbl->type)
+	    return Qfalse;
+
+	data.tbl = RHASH(hash2)->ntbl;
+	data.eql = eql;
+	return rb_exec_recursive_paired(recursive_eql, hash1, hash2, (VALUE)&data);
+    }
 #if 0
     if (!(rb_equal(RHASH_IFNONE(hash1), RHASH_IFNONE(hash2)) &&
 	  FL_TEST(hash1, HASH_PROC_DEFAULT) == FL_TEST(hash2, HASH_PROC_DEFAULT)))
 	return Qfalse;
 #endif
-
-    data.tbl = RHASH(hash2)->ntbl;
-    data.eql = eql;
-    return rb_exec_recursive_paired(recursive_eql, hash1, hash2, (VALUE)&data);
+    return Qtrue;
 }
 
 /*
@@ -2683,7 +3303,10 @@ static VALUE
 reset_hash_type(VALUE arg)
 {
     struct reset_hash_type_arg *p = (struct reset_hash_type_arg *)arg;
-    RHASH(p->hash)->ntbl->type = p->orighash;
+    if (RHASH(p->hash)->ltbl)
+        RHASH(p->hash)->ltbl->type = p->orighash;
+    else
+        RHASH(p->hash)->ntbl->type = p->orighash;
     return Qundef;
 }
 
@@ -2717,12 +3340,19 @@ VALUE
 rb_hash_assoc(VALUE hash, VALUE key)
 {
     st_table *table;
+    li_table *ltable;
     const struct st_hash_type *orighash;
     VALUE args[2];
 
     if (RHASH_EMPTY_P(hash)) return Qnil;
-    table = RHASH(hash)->ntbl;
-    orighash = table->type;
+    if (RHASH(hash)->ltbl) {
+	ltable = RHASH(hash)->ltbl;
+        orighash = ltable->type;
+    }
+    else {
+	table = RHASH(hash)->ntbl;
+        orighash = table->type;
+    }
 
     if (orighash != &identhash) {
 	VALUE value;
@@ -2731,7 +3361,10 @@ rb_hash_assoc(VALUE hash, VALUE key)
 
 	assochash.compare = assoc_cmp;
 	assochash.hash = orighash->hash;
-	table->type = &assochash;
+	if (ltable)
+	    ltable->type = &assochash;
+	else
+	    table->type = &assochash;
 	args[0] = hash;
 	args[1] = key;
 	ensure_arg.hash = hash;
@@ -2898,11 +3531,12 @@ rb_hash_compact(VALUE hash)
 static VALUE
 rb_hash_compact_bang(VALUE hash)
 {
+    st_index_t n;
     rb_hash_modify_check(hash);
-    if (RHASH(hash)->ntbl) {
-	st_index_t n = RHASH(hash)->ntbl->num_entries;
+    n = RHASH_SIZE(hash);
+    if (n) {
 	rb_hash_foreach(hash, delete_if_nil, hash);
-	if (n != RHASH(hash)->ntbl->num_entries)
+	if (n != RHASH_SIZE(hash))
 	    return hash;
     }
     return Qnil;
@@ -2927,15 +3561,24 @@ rb_hash_compact_bang(VALUE hash)
 static VALUE
 rb_hash_compare_by_id(VALUE hash)
 {
-    st_table *identtable;
     if (rb_hash_compare_by_id_p(hash)) return hash;
     rb_hash_modify_check(hash);
 
-    identtable = rb_init_identtable_with_size(RHASH_SIZE(hash));
-    rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)identtable);
-    if (RHASH(hash)->ntbl)
+    if (!RHASH(hash)->ntbl) {
+	li_table *identtable;
+	identtable = linear_init_identtable();
+	rb_hash_foreach(hash, rb_hash_rehash_opt_i, (VALUE)identtable);
+	if (RHASH(hash)->ltbl)
+	    linear_free_table(RHASH(hash)->ltbl);
+	RHASH(hash)->ltbl = identtable;
+    }
+    else {
+	st_table *identtable;
+	identtable = rb_init_identtable_with_size(RHASH_SIZE(hash));
+	rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)identtable);
 	st_free_table(RHASH(hash)->ntbl);
-    RHASH(hash)->ntbl = identtable;
+	RHASH(hash)->ntbl = identtable;
+    }
 
     return hash;
 }
@@ -2952,9 +3595,10 @@ rb_hash_compare_by_id(VALUE hash)
 MJIT_FUNC_EXPORTED VALUE
 rb_hash_compare_by_id_p(VALUE hash)
 {
-    if (!RHASH(hash)->ntbl)
-        return Qfalse;
-    if (RHASH(hash)->ntbl->type == &identhash) {
+    if (RHASH(hash)->ltbl && RHASH(hash)->ltbl->type == &identhash) {
+        return Qtrue;
+    }
+    if (RHASH(hash)->ntbl && RHASH(hash)->ntbl->type == &identhash) {
 	return Qtrue;
     }
     return Qfalse;
@@ -3221,13 +3865,74 @@ add_new_i(st_data_t *key, st_data_t *val, st_data_t arg, int existing)
  * returns non-zero if +key+ was contained.
  */
 int
-rb_hash_add_new_element(VALUE hash, VALUE key, VALUE val)
+rb_hash_add_new_element(VALUE hash, VALUE key, VALUE val) //TODO
 {
-    st_table *tbl = rb_hash_tbl_raw(hash);
+    li_table *ltbl;
+    st_table *tbl;
+    int ret = 0;
     VALUE args[2];
     args[0] = hash;
     args[1] = val;
+    if (!RHASH(hash)->ntbl) {
+	ltbl = hash_ltbl(hash);
+	ret = linear_update(ltbl, (st_data_t)key, add_new_i, (st_data_t)args);
+	if (ret != -1)
+	    return ret;
+	try_convert_table(hash);
+    }
+    tbl = rb_hash_tbl_raw(hash);
     return st_update(tbl, (st_data_t)key, add_new_i, (st_data_t)args);
+
+}
+
+static st_data_t
+linear_stringify(VALUE key)
+{
+    return (rb_obj_class(key) == rb_cString && !RB_OBJ_FROZEN(key)) ?
+        rb_hash_key_str(key) : key;
+}
+
+static void
+linear_bulk_insert(li_table *tab, long argc, const VALUE *argv, VALUE hash)
+{
+    long i;
+    for (i = 0; i < argc; ) {
+	st_data_t k = linear_stringify(argv[i++]);
+	st_data_t v = argv[i++];
+	linear_insert(tab, k, v);
+	RB_OBJ_WRITTEN(hash, Qundef, k);
+	RB_OBJ_WRITTEN(hash, Qundef, v);
+    }
+}
+
+MJIT_FUNC_EXPORTED void
+rb_hash_bulk_insert(long argc, const VALUE *argv, VALUE hash)
+{
+    st_index_t size;
+    li_table *ltbl = RHASH(hash)->ltbl;
+
+    assert(argc % 2 == 0);
+    if (! argc)
+        return;
+    size = argc / 2;
+    if (HASH_HAS_NO_TABLE(hash)) {
+        VALUE tmp = rb_hash_new_with_size(size);
+        RBASIC_CLEAR_CLASS(tmp);
+	if (size <= LINEAR_TABLE_MAX_SIZE) {
+	    RHASH(hash)->ltbl = ltbl = RHASH(tmp)->ltbl;
+	    RHASH(tmp)->ltbl = NULL;
+	}
+	else {
+            RHASH(hash)->ntbl = RHASH(tmp)->ntbl;
+            RHASH(tmp)->ntbl = NULL;
+	}
+    }
+    if (ltbl && (ltbl->num_entries + size <= LINEAR_TABLE_MAX_SIZE)) {
+	linear_bulk_insert(ltbl, argc, argv, hash);
+	return;
+    }
+
+    rb_hash_bulk_insert_into_st_table(argc, argv, hash);
 }
 
 static int path_tainted = -1;
diff --git a/include/ruby/st.h b/include/ruby/st.h
index ede3ff4456..149e0ebaef 100644
--- a/include/ruby/st.h
+++ b/include/ruby/st.h
@@ -143,7 +143,7 @@ CONSTFUNC(st_index_t st_hash_end(st_index_t h));
 CONSTFUNC(st_index_t st_hash_start(st_index_t h));
 #define st_hash_start(h) ((st_index_t)(h))
 
-void rb_hash_bulk_insert(long, const VALUE *, VALUE);
+void rb_hash_bulk_insert_into_st_table(long, const VALUE *, VALUE);
 
 RUBY_SYMBOL_EXPORT_END
 
diff --git a/internal.h b/internal.h
index 45c499d869..d101fd1440 100644
--- a/internal.h
+++ b/internal.h
@@ -670,9 +670,26 @@ struct RComplex {
 #define RCOMPLEX_SET_IMAG(cmp, i) RB_OBJ_WRITE((cmp), &((struct RComplex *)(cmp))->imag,(i))
 #endif
 
+#define LINEAR_TABLE_MAX_SIZE 8
+#define LINEAR_TABLE_BOUND LINEAR_TABLE_MAX_SIZE
+
+typedef struct LinearPair {
+    VALUE key;
+    VALUE record;
+} LinearPair;
+
+typedef struct LinearTable {
+    const struct st_hash_type *type;
+    uint32_t num_entries;
+    uint32_t entries_bound;
+    st_data_t hashes[LINEAR_TABLE_MAX_SIZE];
+    LinearPair pairs[LINEAR_TABLE_MAX_SIZE];
+} li_table;
+
 struct RHash {
     struct RBasic basic;
     struct st_table *ntbl;      /* possibly 0 */
+    struct LinearTable *ltbl;
     int iter_lev;
     const VALUE ifnone;
 };
@@ -685,7 +702,8 @@ struct RHash {
 #undef RHASH_SIZE
 #define RHASH_ITER_LEV(h) (RHASH(h)->iter_lev)
 #define RHASH_IFNONE(h) (RHASH(h)->ifnone)
-#define RHASH_SIZE(h) (RHASH(h)->ntbl ? RHASH(h)->ntbl->num_entries : (st_index_t)0)
+#define RHASH_SIZE_NTBL(h) (RHASH(h)->ntbl ? RHASH(h)->ntbl->num_entries : (st_index_t)0)
+#define RHASH_SIZE(h) (RHASH(h)->ltbl ? RHASH(h)->ltbl->num_entries : RHASH_SIZE_NTBL(h))
 #endif
 
 /* missing/setproctitle.c */
@@ -1356,6 +1374,9 @@ VALUE rb_hash_keys(VALUE hash);
 VALUE rb_hash_values(VALUE hash);
 VALUE rb_hash_rehash(VALUE hash);
 int rb_hash_add_new_element(VALUE hash, VALUE key, VALUE val);
+int linear_foreach(li_table *, int (*)(ANYARGS), st_data_t);
+int linear_lookup(li_table *, st_data_t, st_data_t *);
+void rb_hash_bulk_insert(long, const VALUE *, VALUE);
 #define HASH_PROC_DEFAULT FL_USER2
 
 /* inits.c */
diff --git a/st.c b/st.c
index 1a47525707..0ed2d2b95d 100644
--- a/st.c
+++ b/st.c
@@ -2281,24 +2281,16 @@ st_insert_generic(st_table *tab, long argc, const VALUE *argv, VALUE hash)
     st_rehash(tab);
 }
 
-/* Mimics ruby's { foo => bar } syntax. This function is placed here
-   because it touches table internals and write barriers at once. */
+/* Mimics ruby's { foo => bar } syntax. This function is subpart
+   of rb_hash_bulk_insert. */
 void
-rb_hash_bulk_insert(long argc, const VALUE *argv, VALUE hash)
+rb_hash_bulk_insert_into_st_table(long argc, const VALUE *argv, VALUE hash)
 {
-    st_index_t n;
+    st_index_t n, size = argc / 2;
     st_table *tab = RHASH(hash)->ntbl;
 
-    st_assert(argc % 2 == 0);
-    if (! argc)
-        return;
-    if (! tab) {
-        VALUE tmp = rb_hash_new_with_size(argc / 2);
-        RBASIC_CLEAR_CLASS(tmp);
-        RHASH(hash)->ntbl = tab = RHASH(tmp)->ntbl;
-        RHASH(tmp)->ntbl = NULL;
-    }
-    n = tab->num_entries + argc / 2;
+    tab = rb_hash_tbl_raw(hash);
+    n = tab->num_entries + size;
     st_expand_table(tab, n);
     if (UNLIKELY(tab->num_entries))
         st_insert_generic(tab, argc, argv, hash);
diff --git a/test/ruby/test_time.rb b/test/ruby/test_time.rb
index 50ac569c4e..0aac07b05d 100644
--- a/test/ruby/test_time.rb
+++ b/test/ruby/test_time.rb
@@ -1138,6 +1138,7 @@ def test_memsize
     case size
     when 20 then expect = 50
     when 40 then expect = 86
+    when 48 then expect = 94
     else
       flunk "Unsupported RVALUE_SIZE=#{size}, update test_memsize"
     end
diff --git a/thread.c b/thread.c
index 6181a75ae6..3cf43fab43 100644
--- a/thread.c
+++ b/thread.c
@@ -3506,10 +3506,10 @@ rb_thread_variable_p(VALUE thread, VALUE key)
 
     locals = rb_ivar_get(thread, id_locals);
 
-    if (!RHASH(locals)->ntbl)
-        return Qfalse;
-
-    if (st_lookup(RHASH(locals)->ntbl, ID2SYM(id), 0)) {
+    if (RHASH(locals)->ltbl && linear_lookup(RHASH(locals)->ltbl, ID2SYM(id), 0)) {
+	return Qtrue;
+    }
+    else if (RHASH(locals)->ntbl && st_lookup(RHASH(locals)->ntbl, ID2SYM(id), 0)) {
 	return Qtrue;
     }
 
-- 
2.11.0

